'''
File: routes.py

Purpose:
    This script contains the backend build using fastapi. All the needed api endpoints would be listed here.


'''

from fastapi import FastAPI, HTTPException, Request
from pydantic import BaseModel
import pandas as pd
import numpy as np
import pickle
import sklearn
from datetime import datetime
import utils
import re
import gzip
import json

app = FastAPI()


def validate_date_format(date_str: str) -> bool:
    return bool(re.match(r'^\d{4}-\d{2}-\d{2}$', date_str))


with open('./models/predictive/xgb_tuned.pkl', 'rb') as f:
    prediction_model = pickle.load(f)

# with open('./models/predictive/compressed_decision_tree_final_tuned.pkl', 'rb') as file:
#     prediction_model = pickle.load(file)

with open('./models/forecasting/prophet_forecast_seasonality_holiday.pkl', 'rb') as file:
    np.float_ = np.float64
    forecast_model = pickle.load(file)

@app.get("/")
def read_root():
    data = {
        "description": "The Sales Prediction and Forecasting Application is designed to empower businesses with insights into their sales performance.\
            It combines advanced analytical methods with user-friendly interfaces to facilitate two primary functions:\
                predicting item-level sales and forecasting total store sales.",
        "endpoints": [
            {"path": "/", "method": "GET", "description": "Get Overview of the project and API Documentation"},
            {"path": "/health/", "method": "GET", "description": "Checking the status of the API."},
            {"path": "/sales/national/", "method": "GET", 
             "description": "This endpoint forecasts the total sales of the company across all states, stores, and items.\
                  Given a specific date, it provides a 7-day sales forecast starting from the day after the selected date.", 
             "params": "The selected date is taken as input from the UI to forecast sales for the next 7 days starting from that date.\
                  This date is formatted into a JSON object, which is then used to make the API request, as shown below.", 
             "API request with JSON data": {
                                "date":"2015-04-11"
                            },
             "expected_output": {
                            "2015-04-12":112668.73,
                            "2015-04-13":112698.91,
                            "2015-04-14":112729.08,
                            "2015-04-15":112759.25,
                            "2015-04-16":112789.43,
                            "2015-04-17":112819.6,
                            "2015-04-18":112849.77}
            },
            {"path": "/sales/stores/items/", "method": "GET", 
                "description": "This endpoint predicts the sales of a specific item in a particular store at a given time. \
                                The store_id is a combination of the store's state and a unique number assigned to it. \
                                Similarly, the item_id is a combination of the item's category, department, and item number. \
                                For example, store_id: \"CA_1\" means the store is located in the state of California (CA) and is identified by the number 1.\
                                In the same way, item_id: \"HOUSEHOLD_1_053\" indicates that the item belongs to the 'HOUSEHOLD' category, \
                                falls under the 'HOUSEHOLD_1' department, and is identified by the item number 053. \
                                This process is simplified in the UI, where users can select the state, store number, category, department, and item number separately.\
                                However, the JSON request combines these components into the store_id and item_id, along with the selected date.", 
                
                "params": "The date, state, store number, category, department, and item number are collected from the UI. The store_id is created by combining the state \
                            and store number, while the item_id is generated by combining the category, department, and item number. This information is structured into \
                                a JSON object, which is then used to make the API request, as shown below.",
                
                "API request with JSON data": {
                                    "date":"2015-04-11",
                                    "store_id":"CA_1",
                                    "item_id":"HOUSEHOLD_1_053"
                                }, 
                "expected_output": {"prediction":10.4}
            },
        ]
    }
    return data


@app.get("/health/")
def read_health():
    data = {
        "Health": "**The Application is Runnning.**"
    }
    return data, 200


@app.get("/sales/national/")
def forecast(date:str):
    '''
        Returns next 7 days forecasted sales 

    '''
    if not validate_date_format(date):
        raise HTTPException(status_code=400, detail="Date must be in 'yyyy-mm-dd' format")
    
    start_date = datetime.strptime(date, "%Y-%m-%d")
    date_range = pd.date_range(start=start_date+ pd.Timedelta(days=1), periods=7)
    
    df = pd.DataFrame({'ds': date_range})

    forecast = forecast_model.predict(df)

    forecast_response = forecast[['ds', 'trend']].set_index('ds')['trend'].to_dict()
    formatted_json_data = {date.strftime('%Y-%m-%d'): round(sales, 2) for date, sales in forecast_response.items()}

    return formatted_json_data


# function to sales prediction
def predict_sales(date: str, store_id: str, item_id: str):
    if not validate_date_format(date):
        raise HTTPException(status_code=400, detail="Date must be in 'yyyy-mm-dd' format")
     
    # Prepare the input data for prediction
    input_data = utils.extract_features(date, store_id, item_id)
    
    # Predict the sales
    try:
        # predicted_sell_price = round(prediction_model.predict(input_data)[0],2)
        predicted_sell_price = prediction_model.predict(np.array(input_data))
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error predicting sales: {str(e)}")

    # Return the prediction
    return {"prediction": round(predicted_sell_price.tolist()[0], 2)}



@app.get("/sales/stores/items/")
def get_sales_prediction(date:str, store_id:str, item_id:str):
    
    return predict_sales(date, store_id, item_id)
